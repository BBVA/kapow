package server

import (
	"fmt"
	"log"
	"net/url"
	"os"
	"strconv"

	"github.com/BBVA/kapow/server/control"
	"github.com/BBVA/kapow/server/data"
	"github.com/BBVA/kapow/server/user"
)

// StartServer Starts one instance of each server in a goroutine and remains listening on a channel for trace events generated by them
func StartServer(bindAddr, certfile, keyfile string, interactive bool) error {

	// Parse URI and manage parameters to extract
	userBindAddr, err := url.Parse(bindAddr)
	if err != nil {
		return err
	}

	userPort, err := strconv.ParseInt(userBindAddr.Port(), 10, 64)
	if err != nil {
		return fmt.Errorf("Error extracting port from provided address %s", bindAddr)
	}

	if certfile != "" {
		if _, err := os.Stat(certfile); err != nil {
			if os.IsNotExist(err) {
				return fmt.Errorf("Certfile %s does not exist", certfile)
			}
		}
	}

	if keyfile != "" {
		if _, err := os.Stat(keyfile); err != nil {
			if os.IsNotExist(err) {
				return fmt.Errorf("Keyfile %s does not exist", keyfile)
			}
		}
	}

	ctrlPort := userPort + 1
	dataPort := ctrlPort + 1

	dataServer := data.NewDataServer(userBindAddr.Host(), dataPort, certfile, keyfile)
	ctrlServer := control.NewControlServer(userBindAddr.Host(), ctrlPort, certfile, keyfile)    // Needs a reference to the user server in order to manage routes
	userServer := user.NewUserServer(userBindAddr.Host(), controlServerPort, certfile, keyfile) // Needs a reference to the data server in order to manage handlers

	traceChannel := make(chan string)

	go ctrlServer.Start(traceChannel)
	go dataServer.Start(traceChannel)
	go ctrlServer.Start(traceChannel)

	// Wait for ever while writing logs
	for {
		log.Print(<-traceChannel)
	}
}
